//smallmouth
//@74,@77,@84,@90,@43,@46,@49,@82,@83,@9,@23,@16,@45

precision highp float;
varying highp vec2 textureCoordinate;

uniform sampler2D inputImageTexture;

uniform lowp vec2 location0;
uniform lowp vec2 location1;
uniform lowp vec2 location2;
uniform lowp vec2 location3;
uniform lowp vec2 location4;
uniform lowp vec2 location5;
uniform lowp vec2 location6;
uniform lowp vec2 location7;
uniform lowp vec2 location8;
uniform lowp vec2 location9;
uniform lowp vec2 location10;
uniform lowp vec2 location11;
uniform lowp vec2 location12;

uniform lowp vec2 location13;
uniform lowp vec2 location14;
uniform lowp vec2 location15;
uniform lowp vec2 location16;
uniform lowp vec2 location17;
uniform lowp vec2 location18;
uniform lowp vec2 location19;
uniform lowp vec2 location20;
uniform lowp vec2 location21;
uniform lowp vec2 location22;
uniform lowp vec2 location23;
uniform lowp vec2 location24;
uniform lowp vec2 location25;


#define p74       location0
#define p77       location1
#define p84       location2
#define p90       location3
#define p43       location4
#define p46       location5
#define p49       location6
#define p82       location7
#define p83       location8
#define p9        location9
#define p23       location10
#define p16       location11
#define p45       location12

#define pp74       location13
#define pp77       location14
#define pp84       location15
#define pp90       location16
#define pp43       location17
#define pp46       location18
#define pp49       location19
#define pp82       location20
#define pp83       location21
#define pp9        location22
#define pp23       location23
#define pp16       location24
#define pp45       location25


#define x_a 0.72
#define y_a 1.28


vec4 blendNormal(vec4 c1, vec4 c2)
{
    vec4 outputColor;
    outputColor.r = c1.r + c2.r * c2.a * (1.0 - c1.a);
    outputColor.g = c1.g + c2.g * c2.a * (1.0 - c1.a);
    outputColor.b = c1.b + c2.b * c2.a * (1.0 - c1.a);
    outputColor.a = c1.a + c2.a * (1.0 - c1.a);
    return outputColor;
}

vec2 faceStretch(vec2 textureCoord, vec2 originPosition, vec2 targetPosition, float radius, float curve)
{
    vec2 direction = targetPosition - originPosition;
    float lengthA = length(direction);
    if(lengthA<0.0001)   return direction;
    float lengthB = min(lengthA, radius);
    direction *= lengthB / lengthA;
    float infect = distance(textureCoord, originPosition)/radius;
    infect = clamp(1.0-infect,0.0,1.0);
    infect = pow(infect, curve);
    
    return direction * infect;
}


void main()
{
    
    gl_FragColor            = texture2D(inputImageTexture,textureCoordinate);
    
    vec2 resultCoord        = textureCoordinate;
    vec2 x_y_proportion     = vec2(x_a,y_a);
    vec2 curCoord           = textureCoordinate*x_y_proportion;
    
    if((p46.x>0.03) && (p46.y>0.03))
    {
        
        vec2 realP74            = p74*x_y_proportion;
        vec2 realP77            = p77*x_y_proportion;
        vec2 realP84            = p84*x_y_proportion;
        vec2 realP90            = p90*x_y_proportion;
        vec2 realP43            = p43*x_y_proportion;
        vec2 realP46            = p46*x_y_proportion;
        vec2 realP49            = p49*x_y_proportion;
        vec2 realP82            = p82*x_y_proportion;
        vec2 realP83            = p83*x_y_proportion;
        vec2 realP9             = p9*x_y_proportion;
        vec2 realP23            = p23*x_y_proportion;
        vec2 realP16            = p16*x_y_proportion;
        vec2 realP45            = p45*x_y_proportion;
        
        vec2 realEyeCenter      = (realP74+realP77)*0.5;
        vec2 realMouthCenter    = (realP84+realP90)*0.5;
        
        vec2 srcPoint           = vec2(0.0);
        vec2 dstPoint           = vec2(0.0);
        vec2 offset             = vec2(0.0);
        
        
        float weight = 1.0;
        
        float irisWidth         = distance(realP74,realP77);
        float standardLength    = irisWidth;
        
        
        //narrow eyes
        float eyeRadius                 = standardLength*0.45;
        float toLeftEyeCenterDistance   = distance(curCoord,realP74);
        if(toLeftEyeCenterDistance <= eyeRadius)
        {
            weight      = toLeftEyeCenterDistance/eyeRadius;
            weight      = pow(weight,0.375);
            weight      = clamp(weight,0.0001,1.0);
            curCoord    = realP74+(curCoord-realP74)/weight;
        }
        
        float toRightEyeCenterDistance  = distance(curCoord,realP77);
        if(toRightEyeCenterDistance <= eyeRadius)
        {
            weight      = toRightEyeCenterDistance/eyeRadius;
            weight      = pow(weight,0.375);
            weight      = clamp(weight,0.0001,1.0);
            curCoord    = realP77+(curCoord-realP77)/weight;
        }
        
        //enlarge eyecenter
        {
            float radius = standardLength*0.35;
            float toDistance = distance(curCoord,realEyeCenter);
            if (toDistance<=radius) {
                weight = toDistance/radius;
                weight = pow(weight,0.15);
                curCoord = realEyeCenter+(curCoord-realEyeCenter)*weight;
            }
        }
        
        //nose process
        {
            //enlarge p45
            float radius = standardLength*0.45;
            float toDistance = distance(curCoord,realP45);
            if (toDistance<=radius) {
                weight = toDistance/radius;
                weight = pow(weight,0.11);
                curCoord = realP45+(curCoord-realP45)*weight;
            }
            
            //narrow p46
            radius = standardLength*0.68;
            toDistance = distance(curCoord,realP46);
            if (toDistance<=radius) {
                weight = toDistance/radius;
                weight = pow(weight,0.11);
                weight = clamp(weight,0.0001,1.0);
                curCoord = realP46+(curCoord-realP46)/weight;
            }
        }
        //narrow mouth
        {
            float radius = standardLength*1.1;
            float toMouthDistance = distance(curCoord,realMouthCenter);
            if (toMouthDistance<=radius) {
                weight = toMouthDistance/radius;
                weight = pow(weight,0.325);
                weight = clamp(weight,0.0001,1.0);
                curCoord = realMouthCenter+(curCoord-realMouthCenter)/weight;
            }
        }
        
        resultCoord = curCoord/x_y_proportion;
        
        gl_FragColor = texture2D(inputImageTexture, resultCoord);
    }
    
    if((pp46.x>0.03) && (pp46.y>0.03))
    {
        
        vec2 realP74            = pp74*x_y_proportion;
        vec2 realP77            = pp77*x_y_proportion;
        vec2 realP84            = pp84*x_y_proportion;
        vec2 realP90            = pp90*x_y_proportion;
        vec2 realP43            = pp43*x_y_proportion;
        vec2 realP46            = pp46*x_y_proportion;
        vec2 realP49            = pp49*x_y_proportion;
        vec2 realP82            = pp82*x_y_proportion;
        vec2 realP83            = pp83*x_y_proportion;
        vec2 realP9             = pp9*x_y_proportion;
        vec2 realP23            = pp23*x_y_proportion;
        vec2 realP16            = pp16*x_y_proportion;
        vec2 realP45            = pp45*x_y_proportion;
        
        vec2 realEyeCenter      = (realP74+realP77)*0.5;
        vec2 realMouthCenter    = (realP84+realP90)*0.5;
        
        vec2 srcPoint           = vec2(0.0);
        vec2 dstPoint           = vec2(0.0);
        vec2 offset             = vec2(0.0);
        
        
        float weight = 1.0;
        
        float irisWidth         = distance(realP74,realP77);
        float standardLength    = irisWidth;
        
        
        //narrow eyes
        float eyeRadius                 = standardLength*0.45;
        float toLeftEyeCenterDistance   = distance(curCoord,realP74);
        if(toLeftEyeCenterDistance <= eyeRadius)
        {
            weight      = toLeftEyeCenterDistance/eyeRadius;
            weight      = pow(weight,0.375);
            weight      = clamp(weight,0.0001,1.0);
            curCoord    = realP74+(curCoord-realP74)/weight;
        }
        
        float toRightEyeCenterDistance  = distance(curCoord,realP77);
        if(toRightEyeCenterDistance <= eyeRadius)
        {
            weight      = toRightEyeCenterDistance/eyeRadius;
            weight      = pow(weight,0.375);
            weight      = clamp(weight,0.0001,1.0);
            curCoord    = realP77+(curCoord-realP77)/weight;
        }
        
        //enlarge eyecenter
        {
            float radius = standardLength*0.35;
            float toDistance = distance(curCoord,realEyeCenter);
            if (toDistance<=radius) {
                weight = toDistance/radius;
                weight = pow(weight,0.15);
                curCoord = realEyeCenter+(curCoord-realEyeCenter)*weight;
            }
        }
        
        //nose process
        {
            //enlarge p45
            float radius = standardLength*0.45;
            float toDistance = distance(curCoord,realP45);
            if (toDistance<=radius) {
                weight = toDistance/radius;
                weight = pow(weight,0.11);
                curCoord = realP45+(curCoord-realP45)*weight;
            }
            
            //narrow p46
            radius = standardLength*0.68;
            toDistance = distance(curCoord,realP46);
            if (toDistance<=radius) {
                weight = toDistance/radius;
                weight = pow(weight,0.11);
                weight = clamp(weight,0.0001,1.0);
                curCoord = realP46+(curCoord-realP46)/weight;
            }
        }
        //narrow mouth
        {
            float radius = standardLength*1.1;
            float toMouthDistance = distance(curCoord,realMouthCenter);
            if (toMouthDistance<=radius) {
                weight = toMouthDistance/radius;
                weight = pow(weight,0.325);
                weight = clamp(weight,0.0001,1.0);
                curCoord = realMouthCenter+(curCoord-realMouthCenter)/weight;
            }
        }
        
        resultCoord = curCoord/x_y_proportion;
        
        gl_FragColor = texture2D(inputImageTexture, resultCoord);
    }
    
}


